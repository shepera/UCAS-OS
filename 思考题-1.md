### 1.为什么开始启动计算机的时候，执行的是BIOS代码而不是操作系统自身的代码？

加电的一瞬间，计算机内存中，准确的说是RAM中，还未初始化，没有任何程序。软盘里虽然有操作系统程序，但CPU的逻辑电路被设计为只能运行内存中的程序，没有能力直接从软盘运行操作系统。这就需要硬件主动执行0xffff0处的BIOS程序，由BIOS准备好中断向量表、中断服务程序，接着通过中断“int 0x19”将引导程序bootsect加载至内存，以及后续的一系列操作，最终操作系统自身代码才能位于内存中，被CPU执行。

### 2.为什么BIOS只加载了一个扇区，后续扇区却是由bootsect代码加载？为什么BIOS没有直接把所有需要加载的扇区都加载？

BIOS和操作系统通常由不同的专业团队开发的，每个操作系统的设计者都可以设计自己的启动方案。为了建立协调机制，现行的方案是：两头约定和定位识别。

对操作系统〈这里 Linux0.11)而言，“约定”操作系统的设计者必须把开始执行程序“定位”在启动扇区(软盘中 0盘面 0磁道 1山区 )，其余的程序可以依照操作系统的设计顺序加载在后续的扇区中。

对BIOS而 言,“约定”接到启动操作系统的命令 ，“定位识别”只从启动扇区把代码加 载到0x07C00(BOOTSEG)这个位 (参见Seabios0.6.0/Boot.c文件中的bootdisk函数)。 至于这个扇区中是否是启动程、 是什么操作系统 则不闻不问、一视同仁。如果不是启动程序代码，只会提示错误，其余 用户的责任，与BIOS无关。

### 3.为什么BIOS把bootsect加载到0x07c00，而不是0x00000？加载后又马上挪到0x90000处，是何道理？为什么不一次加载到位？

1）0x07c00是历史约定。0x00000处放了中断向量表

2）系统内存规划？

3）因为

### 4.bootsect、setup、head程序之间是怎么衔接的？给出代码证据。

bootsect$\rightarrow$setup：`jmpi	0,SETUPSEG`

setup$\rightarrow$head：`jmpi	0,8` 



### 5.setup程序的最后是jmpi 0,8 ，为什么这个8不能简单的当作阿拉伯数字8看待，究竟有什么内涵？
8是一个段选择子，看作`0x1000`。这里`1000`的最后两位（00)表示内核特权级，第三位 的0表示GDT，（如果1，则表示LDT）。1000的1表示所选的表(在此就 GDT)的1项。来确定代码段的 基 址和段限长 信息 从图1-23中我们可以看 到，代码 从段基址0x00000000、偏移 0处 也就 head 程序开始位 开始执行的这意味着执行head程序。



### 6.保护模式在“保护”什么？它的“保护”体现在哪里？特权级的目的和意义是什么？分页有“保护”作用吗？

保护内存。 

* 界限检验。
* 类型检验。
* 特权级检验。
* 可寻址区域的限制。
* 例程入口点的限制。
* 指令集的限制。

开启保护模式后自动开启了段级保护。 IA-32 架构的内存管理分为两个部分:分段和分页。在保护模式下，分段机制是必须的，分页机制则是可选的。注意:没有一个标志位可 用来关闭分段功能。分段提供了一种隔离每个进程 或者任务代码、数据和栈模块的机制,保证多个进程或者任务能够在同一个处理器上运 行而不会互相干扰。分页机制实现了传统请求调页的虚拟内存系统，在这种系统中， 程序的执行环境块按需要被映射到物理内存中。分页机制同样可以用来隔离多个任务。

在保护模式操作时，所有内存访问要么通过全局描述符表(GDT – Global Descriptor Table)要么通过局部描述符表(LDT – Local Descriptor Table)。描述符表里的项叫做段描述符。一个段描述符包含一个段的基地 址、访问权限、类型和用法信息。每个段描述符都有一个与之相关的段选择子。段选 择子包含一个对 GDT 或 LDT(与它相关的段描述符)的索引、一个全局/局部标志(决 定段选择子是指向 GDT 还是指向 LDT)和访问权限信息。



**特权集**：除非某些可控制情况之外，处理器使用特权级来阻止较低特权级的进程或任务访 问特权级较高的段。当处理器检测到一个特权违例时，就会产生一个一般保护异常 (#GP)。

根据特权级 别(段的特权级别有 4 级，页有 2 级)的不同，保护机制提供了对特定段或者页进行 限制性访问的能力。比如，可以将重要的操作系统代码和数据放在特权级更高的段(相 比于包含应用程序的段来说)上来保护它们，这样，处理器的保护机制就可以防止应 用程序代码不加控制地访问操作系统的代码和数据。



**分页机制**提供了一些页级保护设施，这些设 施可以与段保护设施配合使用或者取代段的保护措施。例如，它可以强制以页为基础， 实施读写保护。分页机制也可以提供两级即用户级和管理级的保护，这些保护也可以以页为基础来实现。



### 7.在setup程序里曾经设置过gdt，为什么在head程序中将其废弃，又重新设置了一个？为什么设置两次，而不是一次搞好？

原来GDT所在的位置是设计代码时 setup.s里面设置的数据，将来这个setup模块所在的内存位置会在设计缓冲区时被覆盖。如果不改变位置，将来 GDT的内容肯定会被缓冲区覆盖，从而影响系统的运行。这样一来，将来整个内存中唯一安全的地方就是现在head.s所在的位置了。

那么有没有可能在执行setup程序时直接GDT的内容复制到head.s所在的位置? 肯定不能。如果先复制GDT的内容后移动system模块，它就会被后者覆盖 ，如果先移动 system模块，后复制GDT的内容，它又会 head.s对应的程序覆盖 ，而这时head.s还 没有执行。所以，无论如何，都要重新建立GDT。



### 8.内核的线性地址空间是如何分页的？画出从0x000000开始的7个页（包括页目录表、页表所在页）的挂接关系图，就是页目录表的前四个页目录项、第一个个页表的前7个页表项指向什么位置？给出代码证据。

教材p39

<img src="./思考题.assets/截屏2023-10-12 10.23.59.png" alt="截屏2023-10-12 10.23.59" style="zoom:50%;" />0x0000 -> 0x1000, 0x2000, 0x3000, 0x4000

0x1000 -> 0x0000,0x1000,0x2000.... 0x6000

```asm
.align 2
setup_paging:
	movl $1024*5,%ecx		/* 5 pages - pg_dir+4 page tables */
	xorl %eax,%eax
	xorl %edi,%edi			/* pg_dir is at 0x000 */
	cld;rep;stosl 掉方向的循环 页表最后3位: |用户|可读写|存在p|
	movl $pg0+7,_pg_dir			/* set present bit/user r/w */
	movl $pg1+7,_pg_dir+4		/*  --------- " " --------- */
	movl $pg2+7,_pg_dir+8		/*  --------- " " --------- */
	movl $pg3+7,_pg_dir+12		/*  --------- " " --------- */
	movl $pg3+4092,%edi
	movl $0xfff007,%eax		/*  16Mb - 4096 + 7 (r/w user,p) 刷页表项 */
	std
1:	stosl			/* fill pages backwards - more efficient :-) */
	subl $0x1000,%eax
	jge 1b
	xorl %eax,%eax		/* pg_dir is at 0x0000 */
	movl %eax,%cr3		/* cr3 - page directory start */
	movl %cr0,%eax
	orl $0x80000000,%eax
	movl %eax,%cr0		/* set paging (PG) bit 至此保护模式和分页都打开了 */
	ret			/* this also flushes prefetch-queue */
```



### 9.根据内核分页为线性地址恒等映射的要求，推导出四个页表的映射公式，写出页表的设置代码。



<img src="./思考题.assets/截屏2023-10-11 20.59.21.png" alt="截屏2023-10-11 20.59.21" style="zoom:50%;" />

地址x：

页目录表项 ：x >> 22

页表项：(x<<10) >>22

偏移 : (x <<20) >> 20

映射公式：该不会是f(x) = x ？

页表设置代码：

```asm
; head.s
.align 2
setup_paging:
	movl $1024*5,%ecx		/* 5 pages - pg_dir+4 page tables */
	xorl %eax,%eax
	xorl %edi,%edi			/* pg_dir is at 0x000 */
	cld;rep;stosl 掉方向的循环 页表最后3位: |用户|可读写|存在p|
	movl $pg0+7,_pg_dir			/* set present bit/user r/w */
	movl $pg1+7,_pg_dir+4		/*  --------- " " --------- */
	movl $pg2+7,_pg_dir+8		/*  --------- " " --------- */
	movl $pg3+7,_pg_dir+12		/*  --------- " " --------- */
	movl $pg3+4092,%edi
	movl $0xfff007,%eax		/*  16Mb - 4096 + 7 (r/w user,p) 刷页表项 */
	std
1:	stosl			/* fill pages backwards - more efficient :-) */
	subl $0x1000,%eax
	jge 1b
	xorl %eax,%eax		/* pg_dir is at 0x0000 */
	movl %eax,%cr3		/* cr3 - page directory start */
	movl %cr0,%eax
	orl $0x80000000,%eax
	movl %eax,%cr0		/* set paging (PG) bit 至此保护模式和分页都打开了 */
	ret			/* this also flushes prefetch-queue */

```



 

### 10.为什么不用call，而是用ret“调用”main函数？画出调用路线图，给出代码证据。

如果用call调用操作系统 main函数，那 ret时返回给谁?操作系统已经是最底层的系统了，逻辑上不成立。使用ret调用了main就解决了这个问题。而且还加入了万一main函数返回了，可以在L6处卡住。

```asm
after_page_tables:
	pushl $0		# These are the parameters to main :-)
	pushl $0
	pushl $0
	pushl $L6		# return address for main, if it decides to.
	pushl $_main
	jmp setup_paging
L6:
	jmp L6			# main should never return here, but
				# just in case, we know what happens.
				
...

	ret			/* this also flushes prefetch-queue */

```





### GDT为什么为空：

第一项是空段选择子。试图将一个空段选择子(见 3.4.1.“段选择子”)装入 CS 段寄存器或 SS 段寄存 器会产生一个一般保护异常(#GP)。可以将空段选择子装入 DS、ES、FS 或 GS 等寄存 器，但是任何试图通过值为空段选择子的寄存器来访问段的操作，都将产生一般保护 异常(#GP)异常。将空段选择子载入不使用的数据段寄存器，可以很好地检测出对 未使用的段寄存器的访问或者防止对数据段的意外访问。